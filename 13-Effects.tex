\documentclass[DaoFP]{subfiles}
\begin{document}
\setcounter{chapter}{12}

\chapter{效应}

车轮、陶罐和木屋有什么共同点？它们之所以有用，是因为它们中心的空虚。

老子说：“有之以为利，无之以为用。”

\hask{Maybe}函子、列表函子和读者函子有什么共同点？它们中心都有空虚。

\section{带有副作用的编程}

到目前为止，我们一直在讨论基于集合之间的函数（除了非终止情况）来建模的计算。在编程中，这样的函数被称为\emph{全函数}和\emph{纯函数}。

全函数为其所有参数值定义。

纯函数仅根据其参数实现，在闭包的情况下，还包括捕获的值——它无法访问外部世界，更不用说修改外部世界的能力。

然而，大多数现实世界的程序必须与外部世界交互：它们读写文件、处理网络数据包、提示用户输入数据等。大多数编程语言通过允许副作用来解决这个问题。副作用是任何破坏函数全函数性或纯函数性的东西。

不幸的是，命令式语言采用的这种散弹枪方法使得程序推理变得极其困难。在组合有副作用的计算时，必须逐个案例仔细推理副作用的组合。更困难的是，大多数副作用不仅隐藏在特定函数的实现中（而不是接口中），还隐藏在它调用的所有函数的实现中，递归地。

像Haskell这样的纯函数式语言采用的解决方案是将副作用编码在纯函数的\emph{返回类型}中。令人惊讶的是，这对所有相关效应都是可能的。

其思想是，我们使用函数\hask{a -> f b}来代替具有副作用的\hask{a->b}类型的计算，其中类型构造器\hask{f}编码了适当的效应。此时对\hask{f}没有施加任何条件。它甚至不必是\hask{Functor}，更不用说应用函子或单子了。如果我们愿意实现一个单一的整体函数来生成值和副作用，我们就完成了。这个函数的调用者只需解包结果并继续愉快地进行。但编程是关于将复杂动作分解为更简单组件的能力。

以下是常见效应及其纯函数版本的列表。我们将在接下来的章节中讨论组合。

\subsection{部分性}
在命令式语言中，部分性通常使用异常来编码。当函数以“错误”的参数值调用时，它会抛出异常。在某些语言中，异常类型使用特殊语法编码在函数的签名中。

在Haskell中，部分计算可以通过返回\hask{Maybe}函子中的结果的函数来实现。这样的函数在以“错误”参数调用时返回\hask{Nothing}，否则将结果包装在\hask{Just}构造器中。

如果我们想编码更多关于失败类型的信息，可以使用\hask{Either}函子，其中\hask{Left}传统上传递错误数据（通常是简单的\hask{String}）；而\hask{Right}封装真正的返回值（如果可用）。

\hask{Maybe}值函数的调用者不能轻易忽略异常条件。为了提取值，他们必须对结果进行模式匹配并决定如何处理\hask{Nothing}。这与某些命令式语言中的“穷人的\hask{Maybe}”形成对比，后者使用空指针编码错误条件。

\subsection{日志记录}

有时计算必须将一些数据记录在外部数据结构中。日志记录或审计是一种在并发程序中特别危险的副作用，其中多个线程可能同时尝试访问同一日志。

简单的解决方案是让函数返回计算值与要记录的项目配对。换句话说，类型为\hask{a -> b}的日志记录计算可以替换为纯函数：
\begin{haskell}
a -> (b, w)
\end{haskell}
然后，此函数的调用者负责提取要记录的值。这是一个常见的技巧：让函数提供所有数据，并让调用者处理副作用。

为了方便起见，我们稍后将定义一个新类型\hask{Writer w a}，它与\hask{(a, w)}同构。这将允许我们将其作为类型类的实例，例如\hask{Functor}、\hask{Applicative}和\hask{Monad}。

请记住，同构类型可以使用\index{记录语法}记录语法定义，如：
\begin{haskell}
newtype Writer w a = Writer { runWriter :: (a, w) }
\end{haskell}
我们自动获得一对形成同构的函数。其中之一是数据构造器：
\begin{haskell}
Writer :: (a, w) -> Writer w a
\end{haskell}
另一个是它的逆函数：
\begin{haskell}
runWriter :: Writer w a -> (a, w) 
\end{haskell}

\subsection{环境}

一些计算需要对存储在环境中的某些外部数据进行只读访问。与其让计算秘密访问，不如将只读环境作为附加参数传递给函数。如果我们有一个需要访问某些环境\hask{e}的计算\hask{a->b}，我们将其替换为函数\hask{(a, e)->b}。起初，这似乎不符合在返回类型中编码副作用的模式。然而，这样的函数总是可以柯里化为以下形式：
\begin{haskell}
a -> (e -> b)
\end{haskell}
如果我们使用与\hask{e->a}同构的类型\hask{Reader e a}。
\begin{haskell}
newtype Reader e a = Reader { runReader :: e -> a }
\end{haskell}
那么我们可以通过将计算\hask{a->b}替换为以下函数来编码环境副作用：
\begin{haskell}
a -> Reader e b
\end{haskell}
这是一个延迟副作用的例子。我们不想处理副作用，因此我们将此责任委托给调用者。我们的函数生成一个“脚本”，调用者使用\hask{runReader}执行它，传递类型为\hask{e}的合适参数。

\subsection{状态}

最常见的副作用与访问和可能修改某些共享状态有关。不幸的是，共享状态是并发错误的臭名昭著的来源。这在面向对象语言中是一个严重的问题，其中有状态的对象可以在许多客户端之间透明地共享。在Java中，这样的对象可能会被提供单独的互斥锁，但代价是性能受损和死锁风险。

在函数式编程中，我们使状态操作显式化：我们将状态作为附加参数传递，并返回修改后的状态与返回值配对。因此，我们将有状态计算\hask{a -> b}替换为
\begin{haskell}
(a, s) -> (b, s)
\end{haskell}
其中\hask{s}是状态的类型。与之前一样，我们可以柯里化这样的函数以使其变为以下形式：
\begin{haskell}
a -> (s -> (b, s))
\end{haskell}
这个返回类型可以封装在新类型中：
\begin{haskell}
newtype State s a = State { runState :: s -> (a, s) }
\end{haskell}
函数的调用者：
\begin{haskell}
a -> State s b
\end{haskell}
被交给一个脚本。然后可以使用\hask{runState}执行此脚本，它接受初始状态并生成修改后的状态与值配对。

\subsection{非确定性}

想象一下进行一个测量电子自旋的量子实验。一半时间自旋向上，一半时间自旋向下。结果是非确定性的。描述它的一种方法是使用多世界解释：当我们进行实验时，宇宙分裂成两个宇宙，每个结果一个。

函数非确定性意味着什么？这意味着每次调用它都会返回不同的结果。我们可以使用多世界解释来模拟这种行为：我们让函数一次返回\emph{所有可能的结果}。在实践中，我们将满足于一个（可能是无限的）结果列表：

我们将非确定性计算\hask{a -> b}替换为返回函子结果的纯函数——这次是列表函子：
\begin{haskell}
a -> [b]
\end{haskell}
同样，由调用者决定如何处理这些结果。

\subsection{输入/输出}

这是最棘手的副作用，因为它涉及与外部世界的交互。显然，我们无法在计算机程序中模拟整个世界。因此，为了保持程序纯净，交互必须在程序之外进行。诀窍是让程序生成一个脚本。然后将此脚本传递给运行时以执行。运行时是运行程序的有效虚拟机。

这个脚本本身位于不透明的预定义\hask{IO}函子中。隐藏在此函子中的值对程序不可访问：没有\hask{runIO}函数。相反，程序生成的\hask{IO}值至少在概念上是在程序完成后执行的。

实际上，由于Haskell的惰性，I/O的执行与程序的其余部分交错进行。构成程序大部分的纯函数是按需评估的——需求由\hask{IO}脚本的执行驱动。如果不是因为I/O，什么都不会被评估。

Haskell程序生成的\hask{IO}对象称为\hask{main}，其类型签名为：
\begin{haskell}
main :: IO ()
\end{haskell}
它是包含单位的\hask{IO}函子——意味着：除了输入/输出脚本外，没有有用的值。

稍后我们将讨论如何创建\hask{IO}操作。

\subsection{延续}

我们已经看到，作为Yoneda引理的结果，我们可以用接受该值处理程序的函数替换类型为\hask{a}的值。这个处理程序称为延续。调用处理程序被认为是计算的副作用。在纯函数方面，我们将其编码为：
\begin{haskell}
a -> Cont r b
\end{haskell}
其中\hask{Cont r}是封装提供类型为\hask{a}值的承诺的数据类型：
\begin{haskell}
newtype Cont r a = Cont { runCont :: (a -> r) -> r }
\end{haskell}
此函数的调用者负责提供适当的延续，即函数\hask{k :: a -> r}，并检索结果：
\begin{haskell}
runCont :: Cont r a -> (a -> r) -> r
runCont (Cont f) k = f k
\end{haskell}

在笛卡尔闭范畴中，延续由自函子生成：
\[ K_r a = r^{r^a} \]

\begin{exercise}
为\hask{Cont r a}实现\hask{Functor}实例。注意：这是一个协变函子，因为\hask{a}出现在双重否定位置。
\end{exercise}

\subsection{组合有副作用的计算}

现在我们知道如何使用纯函数实现有副作用的计算，我们必须解决组合它们的问题。有两种基本策略可以做到这一点：并行和顺序组合。前者使用应用函子完成，后者使用单子完成。

\end{document}